# .github/workflows/repo-file-sync.yaml
name: Repo File Sync

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 3 * * MON-FRI" # Run workflow at 12:00 JST every MON-FRI
permissions:
  contents: write
jobs:
  sync:
    runs-on: ubuntu-latest
    env:
      SETTINGS: |
        [
          {
            "owner": "kagankan",
            "repo": "sync-test-b",
            "paths": [
              "README.md",
              ".eslintrc",
              "test/*.md"
            ]
          },
          {
            "owner": "kagankan",
            "repo": "sync-test-c",
            "paths": [
              "README.md"
            ]
          }
        ]
    steps:
      - uses: actions/checkout@v4

      - name: デバッグプリント
        run: |
          # SETTINGS を JSON としてパース
          settings=$(echo "$SETTINGS" | jq -c '.[]')
          echo $settings
          # ループ処理
          echo "$settings" | while IFS= read -r setting; do
            owner=$(echo "$setting" | jq -r '.owner')
            repo=$(echo "$setting" | jq -r '.repo')
            paths=$(echo "$setting" | jq -r '.paths[]')

            echo "Processing $owner/$repo with paths:"
            for path in $paths; do
              echo "- $path"
            done
          done
      - name: Generate token
        id: generate_token
        uses: tibdex/github-app-token@v1
        with:
          app_id: ${{ secrets.REPO_FILE_SYNC_APP_ID }}
          private_key: ${{ secrets.REPO_FILE_SYNC_PRIVATE_KEY }}
      - name: 前回の同期時刻を取得
        id: setup
        env:
          GITHUB_TOKEN: ${{ steps.generate_token.outputs.token }}
        run: |
          git config user.name "GitHub App Bot"
          git config user.email "<email@domain.com>"
          git fetch

          settings=$(echo "$SETTINGS" | jq -c '.[]')

          # 変更をもってくる
          echo "$settings" | while IFS= read -r setting; do

            owner=$(echo "$setting" | jq -r '.owner')
            repo=$(echo "$setting" | jq -r '.repo')
            paths=$(echo "$setting" | jq -r '.paths[]')

            echo "Processing $owner/$repo with paths:"
            for path in $paths; do
              echo "- $path"
            done
            
            #  前回の同期時刻を取得
            FILE_SYNC_BRANCH_BASE="file-sync/$repo"
            git checkout -B $FILE_SYNC_BRANCH_BASE origin/$FILE_SYNC_BRANCH_BASE || git checkout -b $FILE_SYNC_BRANCH_BASE
            LAST_SYNC_AT=$(git log -1 --format=%ci HEAD)
            echo "last_sync_at=$LAST_SYNC_AT" >> $GITHUB_OUTPUT
            echo $LAST_SYNC_AT

            # 削除ファイルを反映するために一旦削除
            tree
            rm -rf $(echo "$paths" | sed 's/\n/ /g')
            tree

            # クローン
            REPO="$owner/$repo"
            # ~~1回の更新までに10件くらいしかないだろうという仮定。0が確実だが、多くなりすぎるため。~~
            git clone --filter=blob:none --no-checkout --sparse --depth 1 https://x-access-token:${{ steps.generate_token.outputs.token }}@github.com/$REPO.git $REPO
            # git clone https://x-access-token:${{ steps.generate_token.outputs.token }}@github.com/$REPO.git $REPO

            cd $REPO
            tree -a -I .git
            git config core.sparseCheckout true
            git sparse-checkout set $(echo "$paths" | sed 's/\n/ /g')
            git checkout
            git fetch
            tree -a -I .git

            # どういう原理かわからないけど --sparseをつけないと削除が含まれない？っぽい
            MERGE_COMMITS=$(git log --sparse --first-parent --since "$LAST_SYNC_AT" --oneline --pretty=format:'%s' -- $(echo "$paths" | sed 's/\n/ /g'))
            echo $MERGE_COMMITS
            MERGED_PULLS=$(echo $MERGE_COMMITS | grep -o '#[0-9]\+' | tr '\n' ',' | sed 's/,$//' || echo '')
            echo "|$MERGED_PULLS|"
            echo "merged_pulls=$MERGED_PULLS" >> $GITHUB_OUTPUT

            cd ../../

            # owner=$(echo "$setting" | jq -r '.owner')
            # repo=$(echo "$setting" | jq -r '.repo')
            # paths=$(echo "$setting" | jq -r '.paths[]')
            # REPO="$owner/$repo"
            FILE_SYNC_BRANCH_BASE="file-sync/$repo"
            FILE_SYNC_BRANCH_NEW="file-sync/$repo-${{ github.run_id }}"
            tree -a -I .git
            rsync $REPO/ . -r --exclude '.git/'
            tree -a -I .git
            # Clean up the cloned repository directory
            rm -rf $REPO
  
            git add .
            git commit -m "Update file from source repository" || echo "No changes to commit"
            git push origin $FILE_SYNC_BRANCH_BASE
            COMMIT_HASH=$(git rev-parse HEAD)
            git checkout -b $FILE_SYNC_BRANCH_NEW origin/main
            git cherry-pick $COMMIT_HASH
            git push origin $FILE_SYNC_BRANCH_NEW
            # ワークフローの書き換えにはworkflows権限が必要
            #  ! [remote rejected] file-sync/sync-test-b -> file-sync/sync-test-b (refusing to allow a GitHub App to create or update workflow `.github/workflows/repo-file-sync.yaml` without `workflows` permission)

            gh pr create \
            -B main -H $FILE_SYNC_BRANCH_NEW \
            --reviewer kagankan \
            --title '取り込み' \
            --body '自動生成の取り込みです。マージするかクローズしてください。 # TODO: コンフリクト考慮
              ## 関連PR
              $merged_pulls'

          done
